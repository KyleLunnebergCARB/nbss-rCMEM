---
title: "rMEM"
author: "James T Morris, James R Holmquist, Kathe Todd-Brown"
date: "10/2/2019"
output: html_document
---

The marsh equilibrium model is a concept developed by Morris et al over several iterations. Different versions have in common that as sea-levels rise marsh surfaces dynamically respond to increasing inundation. Organic 

MEM is a 0 dimensional model, meaning it treats spatial dynamics as a single point with no input from or output to other connected patches of the marsh. This makes it relatively simple and tractable.  

Different versions of MEM have these elements in common.

This is a full-blown implementation of MEM. It can be used for hind-casting long-term carbon burial rates, and or hindcasting forecasting carbon removal and net-elevation change. The MEM inputs 

New optionalities include.  
*  More optionalities for inputing biomass parabolas
*  Multiple Plant Species Can be Input
*  Option to incorporate sediment deposition accross 3 different tidal ranges (high, higher high, and spring tides)
*  More flexibility for inputing custom sea-level change, suspended sediment concentraton scenarios. 
*  Custom specification of depth intervals for soil cores
*  Options to create animations of soil profile formation, sea-level and surface elevation change, and biomass and elevation response.

## Load R CTM
The first thing we will do is load the cohort theory model as a dependency.

```{r setup, include=TRUE}
# devtools::install_github("https://github.com/tilbud/rCTM")
require(rCTM)
require(tidyverse)
require(gridExtra)
source("../R/predictedBiomass.R")
source("../R/zToZstar.R")
source("../R/zStarToZ.R")

```

## Define Some Inputs

``` {r define inputs}

# Settings for the functions we're going to run
# Inputs
exStartYear <- 2015 # yearStart
exRslrT1 <- 0.3 # rslr at time 1 (cm/yr)
exRslrTotal <- 100 # cm of total relative seal level rise
exInitElev <- 21.9 # eInit # cm relative to NAVD88
exMSL <- 7.4 # tidal datums, cm relative to NAVD88
exMHW <- 16.9
exMHHW <- 25.4
exMHHWS <- 31.2
exSsc <- 30 # milligrams per liter /  grams per m3
exPresenceAbsence <- data.frame(SCAM = rep(1,100),
                             PHAU = c(rep(0,50), rep(1,50)))
exLunarNodalAmp <- 5 

# Parameters
exBMax <- 2500 # grams per m-2
exZVegMin <- -24.7 # cm relative to datum
exZVegMax <- 44.4
exZVegPeak <- 22.1
exRootToShoot <- 2 # root to shoot ratio
exBgTurnover <- 0.5 # n / year
exRootDepth <- 30 # 
exOmDecayRate <- 0.8
exRecalcitrantFrac <- 0.2
exQ <- 2.8 # n clearences / tide cycle

```

## Build Biomass Parabolas Function

This function takes relative elevation (Z) as an input. It also has parameters descriping parabolic relationship between Z\* and above ground biomass production (grams dry mass m^-2^). It has three manditory parameters, maximum biomass, and minimum and maximum growing elevations.

``` {r parabolicBiomass}

agbFromElv <- predictedBiomass(z=exInitElev, bMax = exBMax, zVegMax = exZVegMax,
                               zVegMin = exZVegMin, zVegPeak = exZVegPeak)

(agbFromElv)

print(agbFromElv)

```

## Create Helper Scripts for Converting Too and From Dimensionless Tidal Elevation

In the biomass functions the units for the elevation can be any thing as long as they are all referenced to the same system. We prefer elevation relative to mean sea level (MSL), normalized to the daily high tide range, mean high water (MHW) This is sometimes referred to as a dimensionless tidal elevation (Z\*). Using Z\* makes biomass curves more comparable accross sites and times, accross which MSL and tidal ranges can vary.  

$$Z^*={E-MSL\over{MHW-MSL}}$$

If you use the most basic settings the function will assume median growing biomass is exactly in between min and max. If you specify a median the function will create a piecewise, flexible parabola.

Here are two scripts for quickly converting to and from dimensionless tidal elevation.

```{r zStarFunctions}
# Target Elevation
targetElevation<- seq((exZVegMin-abs(exZVegMin*.1)), (exZVegMax+abs(exZVegMax*.1)), 
                      by = ((exZVegMax-exZVegMin)/100) )

# Convert elevation to dimensionless tidal elvation
zStarExample <- zToZstar(z=targetElevation, MSL=exMSL, MHW=exMHW)

ggplot(data=data.frame(z=targetElevation, zStar = zStarExample), aes(x=z, y=zStar)) +
  geom_line() +
  geom_vline(data=(z=data.frame(z=c(exMHW, exMSL), 
                                datum=c("MHW", "MSL"))), 
             aes(xintercept = z, lty=datum), color = "blue") +
  geom_hline(data=(z=data.frame(z=c(1, 0), 
                                datum=c("MHW", "MSL"))), 
             aes(yintercept = z, lty=datum), color = "red")

# Convert dimensionless tidal elevation back to regular elevation
zReconstructExample <- zStarToZ(zStar = zStarExample, MSL = exMSL, MHW = exMHW)

# See they're the same
head(targetElevation)
head(zReconstructExample)

```


``` {r exampleParabolas, fig.height = 3.54, fig.width=7}

# targetElevations <- seq(min(zVegMin, MSL-MHHWS), max(zVegMax, MHHWS), by = 4)

displayAGB <- data.frame(elevation=targetElevation) %>%
  mutate(`no peak evl.`= predictedBiomass(z=targetElevation, bMax=exBMax, zVegMax=exZVegMax, zVegMin=exZVegMin, zVegPeak=NA),
         `w/ peak elv.`= predictedBiomass(z=targetElevation, bMax=exBMax, zVegMax=exZVegMax, zVegMin=exZVegMin, zVegPeak=exZVegPeak)) %>%
  gather(value="agb", key='parabolaType', -elevation)


# and plot
ggplot(data=displayAGB, aes(x=elevation, y=agb)) +
  geom_line(color="red", lwd=1.25) +
  facet_wrap(.~parabolaType)

```

## Below Ground Biomass

Below Ground Biomass Production is a function of above ground biomass, root shoot ratio, and below ground turnover rate. We can wrap these functions into a single biomass productivity function.

```{r belowground biomass}

# Simple multiplications
bgbFromAgb <- function(agb, rootShoot) {agb*rootShoot} 

dynamicRootBiomass <- function(z, bMax, zVegMax, zVegMin, zVegPeak, bgTurnover, rootShoot) {
  agb <- predictedBiomass(z=z, bMax=bMax, zVegMax=zVegMax, zVegMin=zVegMin, zVegPeak=zVegPeak)
  bgb <- bgbFromAgb(agb=agb, rootShoot=rootShoot)
  return(bgb)
}

```

But what if we have a more complicated ecology at our wetlands and we want to represent different species?

``` {r multispecies biomass function }

totalBmassElevMultiSpeciesResponse <- function(z, bMax, zVegMax, zVegMin, zVegPeak, bgTurnover, 
                                               rootShoot, rootDepth, speciesCode, presenceAbsence=c(1,1)) {
  
  # Add some stops to make sure that all the input vectors are the same length 
  if (all(is.na(zVegPeak))) {
   inputsList <- list(bMax, zVegMax, zVegMin, bgTurnover, rootShoot, rootDepth) 
  } else {
    inputsList <- list(bMax, zVegMax, zVegMin, zVegPeak, bgTurnover, rootShoot, rootDepth) 
  }
  inputLengths <- mapply(length, x = inputsList)
  if (min(inputLengths)!=max(inputLengths)) { stop("inputs are not all the same length") }
  
  if (all(is.na(speciesCode))) {
    speciesCode <- as.character(1:length(bMax))
  }
  
  # Set up a dataframe with the
  agbBySpecies <- data.frame(agb = rep(NA, length(bMax)*length(z)),
                             elevation = rep(NA, length(bMax)*length(z)),
                             speciesCode = rep(NA, length(bMax)*length(z)))
  
  # iterate through all species
  rowStart = 1
  for (i in 1:length(bMax)) {
    agbBySpecies$agb[rowStart:(i*length(z))] <- agbFromElv(z=z, bMax=bMax[i], zVegMax=zVegMax[i],
                                                  zVegMin=zVegMin[i], zVegPeak=zVegPeak[i])
    agbBySpecies$elevation[rowStart:(i*length(z))] <- z
    agbBySpecies$speciesCode[rowStart:(i*length(z))] <- rep(speciesCode[i], length(z))
    
    rowStart <- (i*length(z))+1
  }
  
  # Get totals
  totalBmass <- agbBySpecies %>%
    group_by(elevation) %>%
    summarise(totalAgb = sum(agb))
  
  # Calculate ratio of total to species agb
  ratioOfSpToTotal <- agbBySpecies %>%
    left_join(totalBmass) %>%
    mutate(bmassRatio = agb/totalAgb) %>%
    # filter(complete.cases(.)) %>%
    select(elevation, speciesCode, bmassRatio) %>% 
    spread(key=speciesCode, value=bmassRatio) %>%
    select(-elevation)
  
  ratioOfSpToTotal[is.na(ratioOfSpToTotal)] <- 0
  
  # weighted average bgTurnover, rootShoot, and rootDepth
  weightedBgTurnover <- rowSums(t(bgTurnover * t(ratioOfSpToTotal)))
  weightedRootShoot <- rowSums(t(rootShoot * t(ratioOfSpToTotal)))
  weightedRootDepth <- rowSums(t(rootDepth * t(ratioOfSpToTotal))) 
  
  totalBmass <- totalBmass %>%
    mutate(totalBgb = bgbFromAgb(agb=totalAgb, bgTurnover = weightedBgTurnover,
                                 rootShoot = weightedRootShoot))
  return(list(totalBmass, agbBySpecies, weightedRootDepth))
} 

```

Here's an example of two different plants, with similar above ground biomass, and root shoot ratio, but a higher marsh that has more turnover than the lower marsh.

``` {r multispecies biomass function example, fig.height = 3.54, fig.width=6}

# Multiple Species Response
bMax=c(2500, 2200)
zVegMax=c(3,4)
zVegMin=c(-1,1)
zVegPeak=c(2,3.5)
bgTurnover=c(1,2.5)
rootShoot=c(2,2)
rootDepth=c(0.5,1)
speciesCode=c("SPAL","SPPA")
z <- seq(-1.1,4.1, by=0.1)

twoSpeciesExample <- totalBmassElevMultiSpeciesResponse(z=z, bMax=bMax, zVegMax=zVegMax, zVegMin=zVegMin,
                                                        zVegPeak=zVegPeak, bgTurnover=bgTurnover,
                                                        rootShoot=rootShoot, rootDepth=rootDepth,
                                                        speciesCode=speciesCode)

agbSpecies <- twoSpeciesExample[[2]] %>%
  mutate(biomassType=paste(speciesCode, " agb", sep="")) %>%
  rename(biomass = agb)

agbBgbDisplay <- twoSpeciesExample[[1]] %>%
  mutate(totalBgb = -totalBgb) %>% 
  gather(key = biomassType, value = biomass, -elevation) %>%
  bind_rows(agbSpecies)

ggplot(agbBgbDisplay, aes(x=elevation, y=biomass)) +
  geom_line(aes(color=biomassType), lwd=1.25)

```

## Build Sedimentation Functions

Sedimentation in MEM is a function of suspended sediment concentration, and three properties of elevation relative to tidal range, the number of tides a year, the mean flood depth, and the mean flood time per tidal cycle. 

The original version of MEM makes some simplistic assumptions about n tides, and flood time. Original MEM assumes that no sedimentation occurs above the MHW line.

```{r simple flood time}

avaliableSediment <- function(floodPct, ssc, q, k=1) {
  
  availableSSC <- ifelse(floodPct < 1/q, # if the sediment column IS NOT able to clear
                         ssc * floodPct/(1/q) * k, # available ssc is total possible caputre 
                         ssc * k) # if the sediment column IS able to clear
  
  return(availableSSC)
}

deliveredSedimentSimple <- function(z, ssc=30, MSL=0, MHW=1, MLW = MSL-MHW, 
                                    nTides=704, q=2.8, k=1) {
  
  # Flood depth in meters is the same as water volume when in m and assuming a 1m2 area of interest
  floodDepth <- ifelse(z<=MHW, (MHW-z)*0.5, 0)
  
  # Mean flood percent is a line, relative position of elevation between MHW and MLW.
  floodPct <- ifelse(z >= MHW, 0, ifelse(z <= MLW, 1, (MHW-z)/(MHW-MLW)))
  
  availableSSC <- avaliableSediment(ssc=ssc, floodPct=floodPct, q=q, k=k)
  
  # Mean flood depth is depth below MHW. If above MHW the marsh does not flood.
  # delivered sediment is the ssc available to the surface (g/m3) multiplied by 
  # the cumulative water volume (cube of water) and number of times the cube passes over the marsh. 
  deliveredSSC <- availableSSC * floodDepth * nTides
  
  return(deliveredSSC)
}

```

Here's an example.

```{r simple sediment example, fig.width=3.54, fig.height=3.54}

deliveredSedimentExample <- mapply(deliveredSedimentSimple, z=targetElevation, MSL=exMSL, MHW=exMHW,
                                   q = exQ)

simpleSedimentPlotData <- data.frame(elevation=targetElevation,
                                     deliveredSediment=deliveredSedimentExample)

ggplot(data=simpleSedimentPlotData, aes(x=elevation, y=deliveredSediment)) +
  geom_line(lwd=1.25) +
  ylab(expression(paste("Delivered Sediment (g m"^"-2",")", sep="")))

```

_Question? Is there a lower limit on sediment delivery to the marsh in MEM? Is it MLW or the lower vegetation line?_

```{r flood time accross datums }

floodTimeFromDatum <- function(z=0, datumHigh=1, datumLow=-1) {
  # Rising time over cell = 6.21 (A/pi - 1)	
  # where A = 2* pi - cos-1 [2 (height of cell – MLW) / (MHW – MLW) - 1] radians
  A1 <- 2 * pi - acos(2 * (z-datumLow) / (datumHigh-datumLow) - 1)
  risingTime <- 6.21 * (A1/pi - 1)
  
  # Falling time over cell = 6.21 (A/pi - 1) where
  # A = 2* - cos-1 [2 (height of cell – MHW) / (MLW – MHW) - 1] radians
  A2 <- 2 * pi - acos(2 * (z-datumHigh) / (datumLow-datumHigh) - 1)
  fallingTime <- 6.21 * (A2/pi - 1)

  # If elevation is above the tidal range indation time is 0
  # If elevation is below inundation time is a full tidal cycle
  # If between inundation time = abs (time rising - 6.21) + time falling
  inundationTime <- ifelse(z>=datumHigh, 0 ,
                           ifelse(z<=datumLow, 6.21*2,
                                  abs(risingTime - 6.21) + fallingTime))
  return(inundationTime)
}

deliveredSediment3TidalCycle <- function(z = 1.1, ssc=30, MSL=0, MHW=1, MHHW=1.3, MHHWS=1.5,
                                        MLW=MSL-MHW, MLLW=MSL-MHHW, MLLWS=MSL-MHHWS,
                                        q=2.8, k=1) {
  
  # Define Constants
  highTidesPerYear <- 352.657
  higherHighTidesPerYear <- 352.657 - 24.720
  springTidesPerYear <- 24.720
  hoursInTidalCycle <- 12.42
  
  # Create a data frame operation so we can use tidy functions to speed this up
  tidalCycles <- data.frame(datumHigh = c(MHW, MHHW, MHHWS), 
                            datumLow = c(MLW, MLLW, MLLWS),
                            nTides = c(highTidesPerYear, higherHighTidesPerYear, springTidesPerYear))
  
  tidalCycles <- tidalCycles %>%
     # Set tidal propoerties to 0 if surface is above tidal range in each case
    dplyr::mutate(nTides = ifelse(z>datumHigh, 0, nTides), # number of tides
           tidalHeight = ifelse(z>datumHigh, 0, (datumHigh-z)*0.5), # Tidal height relative to surface
           floodTime = ifelse(z>datumHigh, 0, floodTimeFromDatum(z=z, # Call flood time function.
                                                                 datumHigh=datumHigh, 
                                                                 datumLow=datumLow)), 
           floodPct = ifelse(z>datumHigh, 0, floodTime / hoursInTidalCycle), # Convert hours to fraction
           availableSSC = avaliableSediment(floodPct=floodPct, ssc=ssc, q=q, k=k), # Call available sediment function
           deliveredSSC = availableSSC * nTides * tidalHeight) # Calculated delivered SSC
  
  # Sum delivered SSC accross tidal cycles
  totalDeliveredSSC <- sum(tidalCycles$deliveredSSC) 
  
  return(totalDeliveredSSC)
}

```

Let's see how the simple vs two tidal cycle modules compare. 

```{r example of simple vs complex sedimentation modules, warning=FALSE, fig.height=3.54, fig.width=7}

deliveredSedimentExample2 <- mapply(deliveredSediment3TidalCycle, z=targetElevation, MSL=exMSL,
                                    MHW=exMHW, MHHW=exMHHW, MHHWS=exMHHWS, q=exQ)

threeTideSedimentPlotData <- data.frame(elevation=targetElevation,
                                        deliveredSediment = deliveredSedimentExample2,
                                        moduleType = rep("3 tide", length(targetElevation)))

simpleSedimentPlotData$moduleType <- rep("simple ", nrow(simpleSedimentPlotData))

sedimentComparisonPlot <- threeTideSedimentPlotData %>%  bind_rows(simpleSedimentPlotData)

totalRange <- ggplot(data=sedimentComparisonPlot, aes(x=elevation, y=deliveredSediment)) +
  geom_line(lwd=1.25, aes(color=moduleType), alpha=0.6) +
  ylab(expression(paste("Delivered Sediment (g m"^"-2",")", sep=""))) +
  ggtitle("Total Tidal Range") +
  geom_vline(data=data.frame(elevation=c(exMSL, exMHW, exMHHW, exMHHWS),
                             datum=c("MSL", "MHW", "MHHW", "MHHWS")), aes(xintercept=elevation,
                                                                          lty=datum))

sedimentComparisonPlotZoomedIn <- filter(sedimentComparisonPlot, elevation>1)

# Zoom In
zoomedIn <- ggplot(data=sedimentComparisonPlotZoomedIn, aes(x=elevation, y=deliveredSediment)) +
  geom_line(lwd=1.25, aes(color=moduleType), alpha=0.6) +
  ylab(expression(paste("Delivered Sediment (g m"^"-2",")", sep=""))) +
  ggtitle("Zoomed in Above MHW")  +
  geom_vline(data=data.frame(elevation=c(exMHW, exMHHW, exMHHWS),
                             datum=c("MHW", "MHHW", "MHHWS")), aes(xintercept=elevation,
                                                                          lty=datum))

grid.arrange(totalRange,zoomedIn, ncol=2)

```

## Set Initial Conditions and Run them to Equilibrium

``` {r set initial conditions}

# totalRootMass_per_area, rootDepthMax, rootTurnover, omDecayRate, 
# mineralInput_g_per_yr.fn = function{mineralInput}
initElv <- 21

# Initial Conditions
initAgb <- predictedBiomass(z=initElv, bMax=exBMax, zVegMin=exZVegMin, zVegMax=exZVegMax, zVegPeak=exZVegPeak) 
initAgb <- initAgb/10000
initBgb <- initAgb*exRootToShoot

initSedimentDelivery <- deliveredSediment3TidalCycle(z=initElv, ssc=exSsc, MSL=exMSL, MHW=exMHW, MHHW=exMHHW, MHHWS=exMHHWS, q=exQ)

initSedimentDelivery <- initSedimentDelivery/1e+06 # mg/l to g/cc (1g/1000mg 1L/1000cc)

depositInitSediment <- function(...) { return(initSedimentDelivery) }

equilibriumCohorts <- runToEquilibrium(totalRootMass_per_area=initBgb, rootDepthMax=exRootDepth, rootTurnover = exBgTurnover,
                                       omDecayRate = list(fast=exOmDecayRate, slow=0), rootOmFrac=list(fast=1-exRecalcitrantFrac, slow=exRecalcitrantFrac),
                                       packing=list(organic=0.085, mineral=1.99), rootDensity=0.085, shape="linear",
                                       mineralInput_g_per_yr.fn = depositInitSediment)
tail(equilibriumCohorts)

# Calculate Steady State Accretion
depth0 <- max(equilibriumCohorts$layer_bottom)

equilibriumCohorts <- addCohort(equilibriumCohorts, totalRootMass_per_area=initBgb, rootDepthMax=exRootDepth, rootTurnover = exBgTurnover,
                                       omDecayRate = list(fast=exOmDecayRate, slow=0), rootOmFrac=list(fast=1-exRecalcitrantFrac, slow=exRecalcitrantFrac),
                                       packing=list(organic=0.085, mineral=1.99), rootDensity=0.085, shape="linear",
                                       mineralInput_g_per_yr.fn = depositInitSediment)

depth1 <- max(equilibriumCohorts$layer_bottom)

steadyStateAccretion = depth1 - depth0

# seems high

ggplot(equilibriumCohorts, aes(y = age, x=layer_bottom)) +
  geom_line()

ggplot(equilibriumCohorts, aes(y = root_mass, x=layer_bottom)) +
  geom_line()

ggplot(equilibriumCohorts, aes(y = fast_OM, x=layer_bottom)) +
  geom_line()

ggplot(equilibriumCohorts, aes(y = slow_OM, x=layer_bottom)) +
  geom_line()

ggplot(equilibriumCohorts, aes(y = mineral, x=layer_bottom)) +
  geom_line()

```

## Build Mean-Sea Level Curve

``` {r build sea-level curve}

buildScenarioCurve <- function(year0, yearEnd=year0+99, MSL, rslr0=0.3, rslrTotal=100, ssc, presenceAbsence,
                               speciesCode=names(presenceAbsence)) {
  
  # Create a sequence of the number of years
  years <- year0:yearEnd
  nYearsOfSim <- length(years) # Put this in args. Replace this with yearEnd.
  
  scenario <- data.frame(index = 1:nYearsOfSim, years = years,
                         MSL = rep(NA, nYearsOfSim),
                         ssc = rep(NA, nYearsOfSim))
  
  # Build the Mean Sea Level Scenario
  # If the input only specifies an initial Mean Sea Level at time = 0 ... 
  if (length(MSL) == 1) {
    # ... create a sea-level rise scenario based on total sea-level rise and inital relative sea-level rise rate
    # Probably could use a stop here in case there are invalid entries of rslr0 and slrTotal
    scenario$MSL[1] <- MSL
    
    # IPCC, 2013 and Sweet et al., 2017
    # MSL(t) = MSL(0) + At + Bt^2 - where t is years from time zero
    # A=[MSL(1)-MSL(0)] – B  
    # Where [MSL(1)-MSL(0)] is the SLR at the start as determined from NOAA trend analyses 
    # Coefficient B is the acceleration term 
    # B = {[MSL(T)-MSL(0)] / T - [MSL(1)-MSL0] } / (T-1) where T - length of the simulation
    
    B <- ((rslrTotal)/nYearsOfSim - rslr0) / (nYearsOfSim-1)
    A <- rslr0 - B
    
    scenario$MSL[2:nYearsOfSim] <- scenario$MSL[1] + A*scenario$index[2:nYearsOfSim] + B*scenario$index[2:nYearsOfSim]^2
    
  } else if (length(MSL) == length(years)) {
    
    # If the user enters in a vector of MSL that is equal to the number of years in the simulation.
    scenario$MSL <- MSL
    
  } else {
    stop("RSLR input is incorrect. Either enter a value at for the beginning and ending of the scenario, or a vector of RSLR one for each year of the scenario.")
  }

  # Add suspended sediment concentration
  if (length(ssc) == 1) {
    # If ssc is a single value.
    scenario$ssc <- rep(ssc, nYearsOfSim)
  } else if (length(ssc) == nYearsOfSim) {
    # If ssc is a vector in equal length to the number of years of the simulation.
    scenario$ssc <- ssc
  } else {
    stop("SSC input is incorrect. Either enter a single average value, or a vector equal in length to the number of years in the scenario.")
  }
  
  # Add species presence or absence if people want to simulate new species arriving
  if (!missing(presenceAbsence)) {
    if (nrow(presenceAbsence) == nYearsOfSim) {
      if (ncol(presenceAbsence) == length(speciesCode)) {
        scenario[1:nYearsOfSim, speciesNames] <- presenceAbsence
      } else {
        stop("Species names are not defined.")
      }
    } else {
      stop("Species presence absence input is incorrect. Enter a dataframe equal in length equal to the number of years in the scenario.")
    }
  } 
  return(scenario)
  # This is a start. We could also allow flexibility to change biomass and sediment addition functions later on to incorporate things like conversions of emergent to forested wetland.
}

```

## Build MHW Lines

``` {r build tidal range scenario}

predictLunarNodalCyle <- function(year, floodElv, MSL0, MSL, lunarNodalAmp=exLunarNodalAmp) {
  # NBuild MHW lines based on MSL, long-term tidal range and lunar nodal amplitude
  MHW <- MSL + (floodElv-MSL0) + (lunarNodalAmp * (sin(2*pi*(year-1983)/18.61)))
  return(MHW)
}

buildHighTideScenario <- function(scenarioCurve, MHW0, MHHW0, MHHWS0, lunarNodalAmp) {
  
  # In create a MHW and add it to the scenario
  scenarioCurve$MHW <- predictLunarNodalCyle(year = scenarioCurve$years, MSL= scenarioCurve$MSL, 
                                             MSL0 = scenarioCurve$MSL[1], floodElv=MHW0, 
                                             lunarNodalAmp=lunarNodalAmp)
  
  # If MHHW and MHHWS are arguements add them to the scenario table too
  if (!missing(MHHW0) & !missing(MHHWS0)) {
    scenarioCurve$MHHW <- predictLunarNodalCyle(year = scenarioCurve$years, MSL=scenarioCurve$MSL,
                                                MSL0 = scenarioCurve$MSL[1], floodElv=MHHW0, 
                                                lunarNodalAmp=lunarNodalAmp)
    scenarioCurve$MHHWS <- predictLunarNodalCyle(year = scenarioCurve$years, MSL= scenarioCurve$MSL, 
                                                 MSL0 = scenarioCurve$MSL[1], floodElv=MHHWS0, 
                                                 lunarNodalAmp=lunarNodalAmp)
  }
  return(scenarioCurve)
}

exScenarioCurve <- buildScenarioCurve(year0 = 2015, MSL = exMSL, rslr0=0.3, rslrTotal = 100, ssc=30)
head(exScenarioCurve)

exScenarioCurve <- buildHighTideScenario(scenarioCurve=exScenarioCurve, MHW0=exMHW, MHHW0=exMHHW, MHHWS0=exMHHWS, 
                                         lunarNodalAmp = exLunarNodalAmp)
head(exScenarioCurve)

ggplot(data=exScenarioCurve) + 
  geom_ribbon(aes(x=years, ymax=MHW, ymin=MSL-(MHW-MSL)), alpha=0.6) +
  geom_line(aes(x=years, y=MSL), color="black") +
  geom_point(aes(x=years, y=MSL), color="black", pch=16) +
  ylab("Water Level (cm NAVD88)") +
  ggtitle("Sea-Level Rise and Tidal Amplitude Scenario.")

highTideScenarios <- exScenarioCurve %>%
  select(-ssc, -index) %>%
  gather(value="elevation", key="high tide", -years, -MSL) %>%
  arrange()

ggplot(data=exScenarioCurve) + 
  geom_line(aes(x=years, y=MSL), color="black") +
  geom_point(aes(x=years, y=MSL), color="black", pch=16) +
  geom_ribbon(data = highTideScenarios, aes(x=years, ymax=elevation, ymin=MSL-(elevation-MSL), color=`high tide`),fill=NA) +
  ylab("Water Level (cm NAVD88)") +
  ggtitle("Sea-Level Rise and Multi-Tide Amplitude Scenario.")

```

## Run Dynamic Step 

``` {r run dynamic step}

trimCohorts <- function(cohorts) {
  cohorts <- cohorts %>%
    filter(complete.cases(.))
  return(cohorts)
} 

# This will be a function eventually, but I'll just scope it out now.
plantElevationType <- "orthometric"

scenario <- exScenarioCurve

{  
  # Trim NA rows from eq cohorts
  cohorts <- equilibriumCohorts
  
  # Preallocate memory for cohort tracking
  nInitialCohorts <- nrow(cohorts)
  nScenarioYears <- nrow(scenario)
  initCohortRows <- nInitialCohorts * nScenarioYears
  newCohortRows <- sum(1:nScenarioYears)
  totalRows <- initCohortRows+newCohortRows
  
  trackCohorts <- data.frame(year=rep(NA, totalRows), age=rep(rep(NA, totalRows)),
                             fast_OM=rep(NA, totalRows), slow_OM=rep(NA, totalRows), 
                             mineral=rep(NA, totalRows), root_mass=rep(NA, totalRows), 
                             layer_top=rep(NA, totalRows), layer_bottom=rep(NA, totalRows),
                             cumCohortVol=rep(NA, totalRows))
  
  # Calculate the biomass 
  profileBottomElv <- initElv - max(cohorts$layer_bottom)
  
  # Convert dimensionless plant growing elevations to real growing elevations
  if (! plantElevationType %in% c("dimensionless", "zStar", "Z*", "zstar")) {
    zStarVegMin <- zToZstar(exZVegMin, exMHW, exMSL)
    zStarVegMax <- zToZstar(exZVegMax, exMHW, exMSL)
    zStarVegPeak <- zToZstar(exZVegPeak, exMHW, exMSL)
  } else {
    zStarVegMin <- exZVegMin
    zStarVegMax <- exZVegMax
    zStarVegPeak <- exZVegPeak
  }

  # Calculate surface elevation
  scenario$surfaceElevation[1] <- initElv
  
  # Iterate through scenario table
  for (i in 2:91) {
    
    # Calculate surface elevation relative to datum
    surfaceElvZStar <- zToZstar(z=scenario$surfaceElevation[i-1], MHW=scenario$MHW[i], MSL=scenario$MSL[i])
    
    # Caluclate dynamic root biomass
    dynamicBgb <- dynamicRootBiomass(z=surfaceElvZStar, bMax=exBMax, zVegMax=zStarVegMax, zVegMin=zStarVegMin, 
                                     zVegPeak=zStarVegPeak, bgTurnover=exBgTurnover, rootShoot=exRootToShoot)/10000
    dynamicMineralPool <- deliveredSediment3TidalCycle(z=scenario$surfaceElevation[i-1], MSL=scenario$MSL[i], MHW=scenario$MHW[i],
                                                       MHHW=scenario$MHHW[i], MHHWS=scenario$MHHWS[i],
                                                       ssc=scenario$ssc[i], q=exQ)/(1000*1000)
    
    # Temporary workaround until I can get Kathe's syntax right
    depositMineralPool <- function(...){return(dynamicMineralPool)}
    
    # Calculate dynamic sediment deliver
    cohorts <- addCohort(cohorts, totalRootMass_per_area=dynamicBgb, rootDepthMax=exRootDepth, 
                         rootTurnover = exBgTurnover, omDecayRate = list(fast=exOmDecayRate, slow=0),
                         rootOmFrac=list(fast=1-exRecalcitrantFrac, slow=exRecalcitrantFrac),
                         packing=list(organic=0.085, mineral=1.99), rootDensity=0.085, shape="linear",
                         mineralInput_g_per_yr.fn = depositMineralPool)
    
    # cohorts <- trimCohorts(cohorts)
    
    scenario$surfaceElevation[i] <- profileBottomElv + max(cohorts$layer_bottom, na.rm=T)
    #scenario$biomass[i] <- dynamicBgb
    #scenario$mineral[i] <- dynamicMineralPool
    #scenario$cumulativeTotalOm[i] <- sum(cohorts$fast_OM, cohorts$root_mass, cohorts$slow_OM, na.rm=T) 
  }
  i=i+1
  
  # Calculate surface elevation relative to datum
    surfaceElvZStar <- zToZstar(z=scenario$surfaceElevation[i-1], MHW=scenario$MHW[i], MSL=scenario$MSL[i])
    
    # Caluclate dynamic root biomass
    dynamicBgb <- dynamicRootBiomass(z=surfaceElvZStar, bMax=exBMax, zVegMax=zStarVegMax, zVegMin=zStarVegMin, 
                                     zVegPeak=zStarVegPeak, bgTurnover=exBgTurnover, rootShoot=exRootToShoot)/10000
    dynamicMineralPool <- deliveredSediment3TidalCycle(z=scenario$surfaceElevation[i-1], MSL=scenario$MSL[i], MHW=scenario$MHW[i],
                                                       MHHW=scenario$MHHW[i], MHHWS=scenario$MHHWS[i],
                                                       ssc=scenario$ssc[i], q=exQ)/(1000*1000)
    
    # Temporary workaround until I can get Kathe's syntax right
    depositMineralPool <- function(...){return(dynamicMineralPool)}
    
    # Calculate dynamic sediment deliver
    failCohorts <- addCohort(cohorts, totalRootMass_per_area=dynamicBgb, rootDepthMax=exRootDepth, 
                         rootTurnover = exBgTurnover, omDecayRate = list(fast=exOmDecayRate, slow=0),
                         rootOmFrac=list(fast=1-exRecalcitrantFrac, slow=exRecalcitrantFrac),
                         packing=list(organic=0.085, mineral=1.99), rootDensity=0.085, shape="linear",
                         mineralInput_g_per_yr.fn = depositMineralPool)
  
  }
}

scenarioNetElevationChange <- scenario %>%
  select(years, MSL, surfaceElevation) %>%
  gather(key="Elevation Type", value="Elevation", -years)

ggplot(data=scenarioNetElevationChange, aes(x=years, y=Elevation)) +
  geom_line(aes(color=`Elevation Type`))

ggplot(data=scenario, aes(x=years, y=biomass)) +
  geom_line()

```

## Run all functions together

## Animate Depth Profile Formation

## Animate Biomass Response to Sea-Level Change

## Animate Marsh Elevation Relative to Mean Sea-Level
